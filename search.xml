<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>使用hexo+github pages搭建博客踩的坑</title>
    <url>/2020/11/04/%E4%BD%BF%E7%94%A8hexo-github-pages%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%B8%A9%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<p>记录一下在使用hexo+github pages构建自己博客的过程中踩到的坑。</p>
<a id="more"></a>

<h2 id="实名认证"><a href="#实名认证" class="headerlink" title="实名认证"></a>实名认证</h2><p>当我们购买成功阿里云域名后，需要将域名进行解析，才能够通过域名访问我们希望访问的地址，但是一定要注意，某些域名必须实名认证才能解析生效，本人在这里排查了好久问题。<br><img src="/2020/11/04/%E4%BD%BF%E7%94%A8hexo-github-pages%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%B8%A9%E7%9A%84%E5%9D%91/1.png"></p>
<h2 id="解析的IP地址"><a href="#解析的IP地址" class="headerlink" title="解析的IP地址"></a>解析的IP地址</h2><p>解析域名，需要我们提供一个IP地址，我是直接输入了教程中的github的服务器ip,实际应该Ping一下自己的网址，将返回的ip地址输入到域名解析的记录值中。<br><img src="/2020/11/04/%E4%BD%BF%E7%94%A8hexo-github-pages%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%B8%A9%E7%9A%84%E5%9D%91/2.png"></p>
]]></content>
      <tags>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title>jar包和war包的区别</title>
    <url>/2020/11/09/jar%E5%8C%85%E5%92%8Cwar%E5%8C%85%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>简述jar包和war包区别。</p>
<a id="more"></a>

<h2 id="jar"><a href="#jar" class="headerlink" title="jar"></a>jar</h2><p>JAR包是类的归档文件，JAR 文件格式以流行的 ZIP 文件格式为基础。与 ZIP 文件不同的是，JAR 文件不仅用于压缩和发布，而且还用于部署和封装库、组件和插件程序，并可被像编译器和 JVM 这样的工具直接使用。<br>jar包里的com里放的就是class文件，②配置文件，但是没有静态资源的文件,③大多数 JAR 文件包含一个 META-INF 目录，它用于存储包和扩展的配置数据，如安全性和版本信息</p>
<h2 id="war"><a href="#war" class="headerlink" title="war"></a>war</h2><p>war包是JavaWeb程序打的包，war包里面包括写的代码编译成的class文件，依赖的包，配置文件，所有的网站页面，包括html，jsp等等。一个war包可以理解为是一个web项目，里面是项目的所有东西。<br>war包里的①WEB-INF里放的class文件和配置文件，②META-INF和jar包作用一样③war包里还包含静态资源的文件</p>
]]></content>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode1-两数之和</title>
    <url>/2020/11/09/LeetCode1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p>LeetCode题解</p>
<a id="more"></a>
<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
<p> </p>
<p>示例:</p>
<p>给定 nums = [2, 7, 11, 15], target = 9</p>
<p>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p>
<p>来源：力扣（LeetCode）</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res=&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target-nums[i]))&#123;</span><br><span class="line">                <span class="keyword">if</span>(i!=map.get(target-nums[i]))&#123;</span><br><span class="line">                    res[<span class="number">0</span>]=map.get(target-nums[i]);</span><br><span class="line">                    res[<span class="number">1</span>]=i;</span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode3-无重复字符的最长子串</title>
    <url>/2020/11/11/LeetCode3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<p>LeetCode题解</p>
<a id="more"></a>
<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<p>示例 1:</p>
<p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:</p>
<p>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:</p>
<p>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p>
<p>来源：力扣（LeetCode）</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cur=<span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Character,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            res=Math.max(res,i-cur);</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(s.charAt(i))&amp;&amp;map.get(s.charAt(i))&gt;=cur)&#123;</span><br><span class="line">                cur=map.get(s.charAt(i))+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(s.charAt(i),i);</span><br><span class="line">        &#125;</span><br><span class="line">        res=Math.max(res,i-cur);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode2-两数相加</title>
    <url>/2020/11/10/LeetCode2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<p>LeetCode题解</p>
<a id="more"></a>
<p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p>示例：</p>
<p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p>
<p>来源：力扣（LeetCode）</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode res=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode cur=res;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="keyword">null</span>||l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            num=<span class="number">0</span>;</span><br><span class="line">            num+=carry;</span><br><span class="line">            carry=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(l1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                num+=l1.val;</span><br><span class="line">                l1=l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                num+=l2.val;</span><br><span class="line">                l2=l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            carry=num/<span class="number">10</span>;</span><br><span class="line">            num=num%<span class="number">10</span>;</span><br><span class="line">            cur.next=<span class="keyword">new</span> ListNode(num);</span><br><span class="line">            cur=cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            cur.next=<span class="keyword">new</span> ListNode(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode4-寻找两个正序数组的中位数</title>
    <url>/2020/11/12/LeetCode4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<p>LeetCode题解</p>
<a id="more"></a>
<p>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。</p>
<p>进阶：你能设计一个时间复杂度为 O(log (m+n)) 的算法解决此问题吗？</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums1 = [1,3], nums2 = [2]<br>输出：2.00000<br>解释：合并数组 = [1,2,3] ，中位数 2<br>示例 2：</p>
<p>输入：nums1 = [1,2], nums2 = [3,4]<br>输出：2.50000<br>解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5<br>示例 3：</p>
<p>输入：nums1 = [0,0], nums2 = [0,0]<br>输出：0.00000<br>示例 4：</p>
<p>输入：nums1 = [], nums2 = [1]<br>输出：1.00000<br>示例 5：</p>
<p>输入：nums1 = [2], nums2 = []<br>输出：2.00000
 </p>
<p>提示：</p>
<p>nums1.length == m<br>nums2.length == n<br>0 &lt;= m &lt;= 1000<br>0 &lt;= n &lt;= 1000<br>1 &lt;= m + n &lt;= 2000<br>-106 &lt;= nums1[i], nums2[i] &lt;= 106</p>
<p>来源：力扣（LeetCode）</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> total=nums1.length+nums2.length;</span><br><span class="line">        <span class="keyword">if</span>(total%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> k=total/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">double</span> d=(findKthNum(nums1,nums2,k)+findKthNum(nums1,nums2,k+<span class="number">1</span>))/<span class="number">2.0</span>;</span><br><span class="line">            <span class="keyword">return</span> d;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> k=total/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">double</span> d =findKthNum(nums1,nums2,k+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findKthNum</span><span class="params">(<span class="keyword">int</span>[] nums1,<span class="keyword">int</span>[] nums2,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r1=<span class="number">0</span>,r2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l1=nums1.length,l2=nums2.length;</span><br><span class="line">        <span class="keyword">int</span> index1=<span class="number">0</span>,index2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(r1==l1)&#123;</span><br><span class="line">                <span class="keyword">return</span> nums2[r2+k-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(r2==l2)&#123;</span><br><span class="line">                <span class="keyword">return</span> nums1[r1+k-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> Math.min(nums1[r1],nums2[r2]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> cur=k/<span class="number">2</span>;</span><br><span class="line">            index1=Math.min(r1+cur,l1)-<span class="number">1</span>;</span><br><span class="line">            index2=Math.min(r2+cur,l2)-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums1[index1]&lt;=nums2[index2])&#123;</span><br><span class="line">                k-=(index1-r1+<span class="number">1</span>);</span><br><span class="line">                r1=index1+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                k-=(index2-r2+<span class="number">1</span>);</span><br><span class="line">                r2=index2+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode922-按奇偶排序数组 II</title>
    <url>/2020/11/12/LeetCode922-%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%20II/</url>
    <content><![CDATA[<p>LeetCode题解</p>
<a id="more"></a>
<p>给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。</p>
<p>对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。</p>
<p>你可以返回任何满足上述条件的数组作为答案。</p>
<p> </p>
<p>示例：</p>
<p>输入：[4,2,5,7]<br>输出：[4,5,2,7]<br>解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受</p>
<p>来源：力扣（LeetCode）</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArrayByParityII(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=A.length-<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span>(left=<span class="number">0</span>;left&lt;A.length;left++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(((left%<span class="number">2</span>)==<span class="number">0</span>&amp;&amp;(A[left]%<span class="number">2</span>)==<span class="number">0</span>)||((left%<span class="number">2</span>)==<span class="number">1</span>&amp;&amp;(A[left]%<span class="number">2</span>)==<span class="number">1</span>))&#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               right=A.length-<span class="number">1</span>;</span><br><span class="line">               <span class="keyword">if</span>(left%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                   <span class="keyword">while</span>(A[right]%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                       right--;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="keyword">while</span>(A[right]%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                       right--;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               swap(A,right,left);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] A,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=A[i];</span><br><span class="line">        A[i]=A[j];</span><br><span class="line">        A[j]=temp;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode328-奇偶链表</title>
    <url>/2020/11/13/LeetCode328-%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>LeetCode题解</p>
<a id="more"></a>
<p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p>
<p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p>
<p>示例 1:</p>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL<br>示例 2:</p>
<p>输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL<br>输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</p>
<p>来源：力扣（LeetCode）</p>
<p> </p>
<p>示例：</p>
<p>输入：[4,2,5,7]<br>输出：[4,5,2,7]<br>解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受</p>
<p>来源：力扣（LeetCode）</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">oddEvenList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>||head.next.next==<span class="keyword">null</span>)<span class="keyword">return</span> head;</span><br><span class="line">        ListNode even=head;</span><br><span class="line">        ListNode odd=head.next;</span><br><span class="line">        ListNode oddHead=odd;</span><br><span class="line">        <span class="keyword">while</span>(odd!=<span class="keyword">null</span>&amp;&amp;odd.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           even.next=odd.next;</span><br><span class="line">           even=even.next;</span><br><span class="line">           odd.next=even.next;</span><br><span class="line">           odd=odd.next;</span><br><span class="line">        &#125;</span><br><span class="line">        even.next=oddHead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode5-最长回文子串</title>
    <url>/2020/11/13/LeetCode5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<p>LeetCode题解</p>
<a id="more"></a>
<p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>
<p>示例 1：</p>
<p>输入: “babad”<br>输出: “bab”<br>注意: “aba” 也是一个有效答案。<br>示例 2：</p>
<p>输入: “cbbd”<br>输出: “bb”</p>
<p>来源：力扣（LeetCode）</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        String res=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> len=s.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp =<span class="keyword">new</span> <span class="keyword">boolean</span>[len][len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l&lt;=len;l++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> index=<span class="number">0</span>;index&lt;=len-l;index++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(l==<span class="number">1</span>)&#123;</span><br><span class="line">                    dp[index][index]=<span class="keyword">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(l==<span class="number">2</span>)&#123;</span><br><span class="line">                    dp[index][index+l-<span class="number">1</span>]=(s.charAt(index)==s.charAt(index+<span class="number">1</span>));</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[index][index+l-<span class="number">1</span>]=dp[index+<span class="number">1</span>][index+l-<span class="number">2</span>]&amp;&amp;(s.charAt(index)==s.charAt(index+l-<span class="number">1</span>));</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">if</span>(dp[index][index+l-<span class="number">1</span>]&amp;&amp;(l&gt;res.length()))&#123;</span><br><span class="line">                    res=s.substring(index,index+l);</span><br><span class="line">                &#125;               </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode406-根据身高重建队列</title>
    <url>/2020/11/16/LeetCode406-%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>LeetCode题解</p>
<a id="more"></a>
<p>假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。</p>
<p>注意：<br>总人数少于1100人。</p>
<p>示例</p>
<p>输入:<br>[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]</p>
<p>输出:<br>[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]</p>
<p>来源：力扣（LeetCode）</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] reconstructQueue(<span class="keyword">int</span>[][] people) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;people.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(count==people[j][<span class="number">1</span>])&#123;</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(people[j][<span class="number">0</span>]&gt;people[i][<span class="number">0</span>])&#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                    count++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(people[j][<span class="number">0</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode6-Z字形变换</title>
    <url>/2020/11/16/LeetCode6-Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<p>LeetCode题解</p>
<a id="more"></a>
<p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p>
<p>比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：</p>
<p>L   C   I   R<br>E T O E S I I G<br>E   D   H   N<br>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。</p>
<p>请你实现这个将字符串进行指定行数变换的函数：</p>
<p>string convert(string s, int numRows);<br>示例 1:</p>
<p>输入: s = “LEETCODEISHIRING”, numRows = 3<br>输出: “LCIRETOESIIGEDHN”<br>示例 2:</p>
<p>输入: s = “LEETCODEISHIRING”, numRows = 4<br>输出: “LDREOEIIECIHNTSG”<br>解释:</p>
<p>L     D     R<br>E   O E   I I<br>E C   I H   N<br>T     S     G</p>
<p>来源：力扣（LeetCode）</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numRows==<span class="number">1</span>)<span class="keyword">return</span> s;</span><br><span class="line">        ArrayList&lt;StringBuilder&gt; sbs=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numRows;i++)&#123;</span><br><span class="line">            sbs.add(<span class="keyword">new</span> StringBuilder());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> row=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(index&lt;s.length())&#123;</span><br><span class="line">            <span class="keyword">while</span>(index&lt;s.length()&amp;&amp;row&lt;numRows)&#123;</span><br><span class="line">                sbs.get(row).append(s.charAt(index));</span><br><span class="line">                row++;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            row--;</span><br><span class="line">            row--;</span><br><span class="line">            <span class="keyword">while</span>(index&lt;s.length()&amp;&amp;row&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                sbs.get(row).append(s.charAt(index));</span><br><span class="line">                row--;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder res=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(StringBuilder sb:sbs)&#123;</span><br><span class="line">            res.append(sb);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>在mybatis中#{}和${}的区别</title>
    <url>/2020/11/16/%E5%9C%A8mybatis%E4%B8%AD%7B%7D%E5%92%8C$%7B%7D%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>在mybatis中#{}和${}的区别，使用场景。</p>
<a id="more"></a>

<p>动态sql是mybatis的主要特性之一。在mapper中定义的参数传到xml中之后，在查询之前mybatis会对其进行动态解析。<br>mybatis提供了两种支持动态sql的语法：#{} 、${}。</p>
<p>select * from t_user where username = ‘${username}’;<br>select * from t_user where username = #{username};</p>
<p>username传参一致的话,这两种执行的结果是一样的，但是这两种方式在动态sql解析阶段的处理是不一样的。</p>
<p>1、#{}</p>
<p>解析为一个JDBC预编译语句（prepared statement）的参数标记符，把参数部分用占位符？代替。动态解析为：<br>select * from t_user where username = ？ ;<br>而传入的参数将会经过PreparedStatement方法的强制类型检查和安全检查等处理，最后作为一个合法的字符串传入。</p>
<p>2、${}</p>
<p>这种方式只会做简单的字符串替换，在动态SQL解析阶段将会进行变量替换，假如传递的参数为Alice，最终处理结果如下：<br>select * from t_user where username = ‘Alice’ ;<br>这样在预编译之前的sql语句已经不包含变量了，因此可以看出${} 变量的替换阶段是在动态SQL解析阶段。</p>
<p>3、#{}与${}的区别</p>
<p>(1)、是否预防SQL注入</p>
<p>以上不同的处理方式可以看出，#{}预处理之后可以预防SQL注入；而${}在预编译之前就已经被替换，有被注入的风险，如下例：<br>如果传入的username 为 a’ or ‘1=1，那么使用${}处理后直接替换字符串的sql就解析为：<br>select * from t_user where username = a’ or ‘1=1’ ;<br>这样的话所有的用户数据就被查出来了，这样就属于SQL注入。<br>如果使用#{}，经过sql动态解析和预编译，会把单引号转义为&#39;那么sql最终解析为：<br>select * from t_user where username = “a&#39; or &#39;1=1 “;//这样会查不出任何数据，有效阻止sql注入<br>有的业务场景经常用到模糊查询，也就是like处理，推荐使用以下处理方式：<br>t_user.username like #username#<br>java代码里：<br>if (!StringUtil.isEmpty(this.username)) {<br>table.setUsername(“%” + this.username + “%”);<br>}<br>或者也可以使用数据库函数进行连接处理：<br>select  * from t_user u where username  like CONCAT(‘%’,#username#, ‘%’)<br>注意：以上就可以发现在某些特定场景下只能用${}，比如order by 后的排序字段，表名、列名,因为需要替换为不变的常量。如果表名中使用#{}的话，会变成如下：<br>select * from #{tablename}–&gt;tablename传参为t_user —&gt;处理后变成 select * from ‘t_user’，没有这样的表名，这样的话就会报错了，order by 同理。<br>(2)、性能处理方面</p>
<p>因为预编译语句对象可以重复利用，把一个sql预编译后产生的PreparedStatement对象缓存下来，下次对于同一个sql，可以直接使用缓存的PreparedStatement对象，mybatis默认情况下，对所有的sql进行预编译，这样的话#{}的处理方式性能会相对高些。</p>
<p>3、简单总结一下：</p>
<p>(1)、mybatis能使用#{}的时候尽量使用#{}</p>
<p>(2)、表名、order by的排序字段作为变量时，使用${}。</p>
<p>(3)、#不需要关注数据类型，mybatis实现自动数据类型转换；$不做数据类型转换，需要自行判断数据类型</p>
<p>(4)、#是预编译的方式，$是直接拼接。</p>
]]></content>
      <tags>
        <tag>知识点</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode1030-距离顺序排列矩阵单元格</title>
    <url>/2020/11/17/LeetCode1030-%E8%B7%9D%E7%A6%BB%E9%A1%BA%E5%BA%8F%E6%8E%92%E5%88%97%E7%9F%A9%E9%98%B5%E5%8D%95%E5%85%83%E6%A0%BC/</url>
    <content><![CDATA[<p>LeetCode题解</p>
<a id="more"></a>
<p>给出 R 行 C 列的矩阵，其中的单元格的整数坐标为 (r, c)，满足 0 &lt;= r &lt; R 且 0 &lt;= c &lt; C。</p>
<p>另外，我们在该矩阵中给出了一个坐标为 (r0, c0) 的单元格。</p>
<p>返回矩阵中的所有单元格的坐标，并按到 (r0, c0) 的距离从最小到最大的顺序排，其中，两单元格(r1, c1) 和 (r2, c2) 之间的距离是曼哈顿距离，|r1 - r2| + |c1 - c2|。（你可以按任何满足此条件的顺序返回答案。）</p>
<p> </p>
<p>示例 1：</p>
<p>输入：R = 1, C = 2, r0 = 0, c0 = 0<br>输出：[[0,0],[0,1]]<br>解释：从 (r0, c0) 到其他单元格的距离为：[0,1]</p>
<p>来源：力扣（LeetCode）</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] allCellsDistOrder(<span class="keyword">int</span> R, <span class="keyword">int</span> C, <span class="keyword">int</span> r0, <span class="keyword">int</span> c0) &#123;</span><br><span class="line">        <span class="keyword">int</span> len=R*C;</span><br><span class="line">        <span class="keyword">int</span>[][] res=<span class="keyword">new</span> <span class="keyword">int</span>[len][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;R;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;C;j++)&#123;</span><br><span class="line">                res[index][<span class="number">0</span>]=i;</span><br><span class="line">                res[index][<span class="number">1</span>]=j;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(res, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (Math.abs(a[<span class="number">0</span>] - r0) + Math.abs(a[<span class="number">1</span>] - c0)) - </span><br><span class="line">                (Math.abs(b[<span class="number">0</span>] - r0) + Math.abs(b[<span class="number">1</span>] - c0));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-3.从尾到头打印链表</title>
    <url>/2020/11/17/%E5%89%91%E6%8C%87offer-3.%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>剑指offer题解。</p>
<a id="more"></a>

<p>题目描述<br>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">*    public class ListNode &#123;</span></span><br><span class="line"><span class="comment">*        int val;</span></span><br><span class="line"><span class="comment">*        ListNode next = null;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*        ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">*            this.val = val;</span></span><br><span class="line"><span class="comment">*        &#125;</span></span><br><span class="line"><span class="comment">*    &#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(listNode==<span class="keyword">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">        Stack&lt;Integer&gt; s=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(listNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            s.push(listNode.val);</span><br><span class="line">            listNode=listNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!s.isEmpty())&#123;</span><br><span class="line">            res.add(s.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-1.二维数组中查找</title>
    <url>/2020/11/17/%E5%89%91%E6%8C%87offer-1.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p>剑指offer题解。</p>
<a id="more"></a>

<p>题目描述<br>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<br>示例1<br>输入</p>
<p>7,[[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]]<br>返回值</p>
<p>true</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=array.length;</span><br><span class="line">        <span class="keyword">int</span> b=array[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> x=a-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x&gt;=<span class="number">0</span>&amp;&amp;y&lt;b)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[x][y]==target)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[x][y]&gt;target)&#123;</span><br><span class="line">                x--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                y++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-2.替换空格</title>
    <url>/2020/11/17/%E5%89%91%E6%8C%87offer-2.%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
    <content><![CDATA[<p>剑指offer题解。</p>
<a id="more"></a>

<p>题目描述<br>题目描述<br>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<p>true</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb=<span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i)==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                sb.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sb.append(str.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode11-盛最多水的容器</title>
    <url>/2020/11/19/LeetCode11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<p>LeetCode题解</p>
<a id="more"></a>
<p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>说明：你不能倾斜容器。</p>
<p>来源：力扣（LeetCode）</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            res=Math.max(res,Math.min(height[i],height[j])*(j-i));</span><br><span class="line">            <span class="keyword">if</span>(height[i]&gt;height[j])&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode134-加油站</title>
    <url>/2020/11/18/LeetCode134-%E5%8A%A0%E6%B2%B9%E7%AB%99/</url>
    <content><![CDATA[<p>LeetCode题解</p>
<a id="more"></a>
<p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p>
<p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p>
<p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p>
<p>说明: </p>
<p>如果题目有解，该答案即为唯一答案。<br>输入数组均为非空数组，且长度相同。<br>输入数组中的元素均为非负数。<br>示例 1:</p>
<p>输入:<br>gas  = [1,2,3,4,5]<br>cost = [3,4,5,1,2]</p>
<p>输出: 3</p>
<p>解释:<br>从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油<br>开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油<br>开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油<br>开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油<br>开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油<br>开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。<br>因此，3 可为起始索引。</p>
<p>来源：力扣（LeetCode）</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="keyword">int</span>[] gas, <span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;gas.length)&#123;</span><br><span class="line">            <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> curGas=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(count&lt;gas.length)&#123;</span><br><span class="line">                <span class="keyword">int</span> j=(i+count)%gas.length;</span><br><span class="line">                curGas=curGas+gas[j]-cost[j];</span><br><span class="line">               </span><br><span class="line">                <span class="keyword">if</span>(curGas&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                 count++;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="keyword">if</span>(count==gas.length)&#123;</span><br><span class="line">               <span class="keyword">return</span> i;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               i=i+count+<span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode283-移动零</title>
    <url>/2020/11/19/LeetCode283-%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
    <content><![CDATA[<p>LeetCode题解</p>
<a id="more"></a>
<p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p>示例:</p>
<p>输入: [0,1,0,3,12]<br>输出: [1,3,12,0,0]</p>
<p>来源：力扣（LeetCode）</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp=nums[index];</span><br><span class="line">                nums[index]=nums[i];</span><br><span class="line">                nums[i]=temp;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-4.重建二叉树</title>
    <url>/2020/11/19/%E5%89%91%E6%8C%87offer-4.%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>剑指offer题解。</p>
<a id="more"></a>

<p>题目描述<br>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> constuct(pre,in,<span class="number">0</span>,pre.length-<span class="number">1</span>,<span class="number">0</span>,in.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">constuct</span><span class="params">(<span class="keyword">int</span>[] pre,<span class="keyword">int</span>[] in,<span class="keyword">int</span> ph,<span class="keyword">int</span> pe,<span class="keyword">int</span> ih,<span class="keyword">int</span> ie)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ph&gt;pe||ih&gt;ie)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=ih;i&lt;=ie;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre[ph]==in[i])&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode node =<span class="keyword">new</span> TreeNode(pre[ph]);</span><br><span class="line">        node.left=constuct(pre,in,ph+<span class="number">1</span>,ph+num,ih,ih+num-<span class="number">1</span>);</span><br><span class="line">        node.right=constuct(pre,in,ph+num+<span class="number">1</span>,pe,ih+num+<span class="number">1</span>,ie);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-5.用两个栈实现队列</title>
    <url>/2020/11/19/%E5%89%91%E6%8C%87offer-5.%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>剑指offer题解。</p>
<a id="more"></a>

<p>题目描述<br>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> stack2.pop();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">                 stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-6.旋转数组的最小数字</title>
    <url>/2020/11/19/%E5%89%91%E6%8C%87offer-6.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p>剑指offer题解。</p>
<a id="more"></a>

<p>题目描述<br>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end=array.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;end)&#123;</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">int</span> mid=start+(end-start)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[mid]==array[start]&amp;&amp;array[mid]==array[start])&#123;</span><br><span class="line">                <span class="keyword">return</span> helper(array,start,end);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(array[mid]&lt;=array[end])&#123;</span><br><span class="line">                end=mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                start=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[start];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;end;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(array[i]&gt;array[i+<span class="number">1</span>])&#123;</span><br><span class="line">               <span class="keyword">return</span> array[i+<span class="number">1</span>];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> array[start];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode147-对链表进行插入排序</title>
    <url>/2020/11/20/LeetCode147-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>LeetCode题解</p>
<a id="more"></a>
<p>对链表进行插入排序。</p>
<p>插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。<br>每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。</p>
<p>来源：力扣（LeetCode）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">insertionSortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)<span class="keyword">return</span> head;</span><br><span class="line">        ListNode res=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        res.next=head;</span><br><span class="line">        ListNode cur = head.next;</span><br><span class="line">        ListNode pre = head;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.val&gt;=pre.val)&#123;</span><br><span class="line">                pre=pre.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ListNode node =res;</span><br><span class="line">                <span class="keyword">while</span>(cur.val&gt;=node.next.val)&#123;</span><br><span class="line">                    node=node.next;</span><br><span class="line">                &#125;</span><br><span class="line">                pre.next=cur.next;</span><br><span class="line">                cur.next=node.next;</span><br><span class="line">                node.next=cur;</span><br><span class="line">                &#125;</span><br><span class="line">            cur=pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-7.菲波那切数列</title>
    <url>/2020/11/20/%E5%89%91%E6%8C%87offer-7.%E6%96%90%E6%B3%A2%E9%82%A3%E5%88%87%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<p>剑指offer题解。</p>
<a id="more"></a>

<p>题目描述<br>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。<br>n&lt;=39。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>||n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Fibonacci(n-<span class="number">2</span>)+Fibonacci(n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode148-排序链表</title>
    <url>/2020/11/21/LeetCode148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>LeetCode题解</p>
<a id="more"></a>
<p>给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</p>
<p>进阶：</p>
<p>你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？
 </p>
<p>来源：力扣（LeetCode）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">        ListNode node =head;</span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            len++;</span><br><span class="line">            node=node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode res=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        res.next=head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> subLen=<span class="number">1</span>;subLen&lt;len;subLen=subLen*<span class="number">2</span>)&#123;</span><br><span class="line">            ListNode pre=res,cur=res.next;</span><br><span class="line">            <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                ListNode head1=cur;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;subLen&amp;&amp;cur.next!=<span class="keyword">null</span>;i++)&#123;</span><br><span class="line">                    cur=cur.next;</span><br><span class="line">                &#125;</span><br><span class="line">                ListNode head2=cur.next;</span><br><span class="line">                cur.next=<span class="keyword">null</span>;</span><br><span class="line">                cur=head2;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;subLen&amp;&amp;cur!=<span class="keyword">null</span>&amp;&amp;cur.next!=<span class="keyword">null</span>;i++)&#123;</span><br><span class="line">                    cur=cur.next;</span><br><span class="line">                &#125;</span><br><span class="line">                ListNode next=<span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    next=cur.next;</span><br><span class="line">                    cur.next=<span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ListNode merged=merge(head1,head2);</span><br><span class="line">                pre.next=merged;</span><br><span class="line">                <span class="keyword">while</span>(pre.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    pre=pre.next;</span><br><span class="line">                &#125;</span><br><span class="line">                cur=next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode temp = dummyHead, temp1 = head1, temp2 = head2;</span><br><span class="line">        <span class="keyword">while</span> (temp1 != <span class="keyword">null</span> &amp;&amp; temp2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp1.val &lt;= temp2.val) &#123;</span><br><span class="line">                temp.next = temp1;</span><br><span class="line">                temp1 = temp1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp.next = temp2;</span><br><span class="line">                temp2 = temp2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp.next = temp1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp.next = temp2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-12.数值的整数次方</title>
    <url>/2020/11/21/%E5%89%91%E6%8C%87offer-12.%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</url>
    <content><![CDATA[<p>剑指offer题解。</p>
<a id="more"></a>

<p>题目描述<br>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p>
<p>保证base和exponent不同时为0</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(exponent==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(exponent==<span class="number">1</span>)<span class="keyword">return</span> base;</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(exponent&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            exponent=-exponent;</span><br><span class="line">            flag=<span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> res=base;</span><br><span class="line">        <span class="keyword">while</span>(exponent!=<span class="number">1</span>)&#123;</span><br><span class="line">            res=res*res;</span><br><span class="line">            exponent/=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(exponent==<span class="number">1</span>)&#123;</span><br><span class="line">            res*=base;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            res=<span class="number">1</span>/res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-10.矩形覆盖</title>
    <url>/2020/11/20/%E5%89%91%E6%8C%87offer-10.%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/</url>
    <content><![CDATA[<p>剑指offer题解。</p>
<a id="more"></a>

<p>题目描述<br>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> RectCover(target-<span class="number">1</span>)+RectCover(target-<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-13.调整数组顺序使奇数位于偶数前面</title>
    <url>/2020/11/21/%E5%89%91%E6%8C%87offer-13.%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</url>
    <content><![CDATA[<p>剑指offer题解。</p>
<a id="more"></a>

<p>题目描述<br>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;array.length)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;array.length&amp;&amp;array[i]%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            j=i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;array.length&amp;&amp;array[j]%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j&lt;array.length)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp=array[j];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> index=j;j&gt;i;j--)&#123;</span><br><span class="line">                    array[j]=array[j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                array[i]=tmp;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-11.二进制中1的个数</title>
    <url>/2020/11/21/%E5%89%91%E6%8C%87offer-11.%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<p>剑指offer题解。</p>
<a id="more"></a>

<p>题目描述<br>输入一个整数，输出该数32位二进制表示中1的个数。其中负数用补码表示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(flag!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((flag&amp;n)!=<span class="number">0</span>)num++;</span><br><span class="line">            flag&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-8.跳台阶</title>
    <url>/2020/11/20/%E5%89%91%E6%8C%87offer-8.%E8%B7%B3%E5%8F%B0%E9%98%B6/</url>
    <content><![CDATA[<p>剑指offer题解。</p>
<a id="more"></a>

<p>题目描述<br>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">1</span>||target==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> JumpFloor(target-<span class="number">1</span>)+JumpFloor(target-<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-9.变态跳台阶</title>
    <url>/2020/11/20/%E5%89%91%E6%8C%87offer-9.%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6/</url>
    <content><![CDATA[<p>剑指offer题解。</p>
<a id="more"></a>

<p>题目描述<br>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">1</span>)<span class="keyword">return</span> target;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*JumpFloorII(target-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-14.链表中倒数第k个结点</title>
    <url>/2020/11/21/%E5%89%91%E6%8C%87offer-14.%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<p>剑指offer题解。</p>
<a id="more"></a>

<p>题目描述<br>输入一个链表，输出该链表中倒数第k个结点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow=head,fast=head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fast=fast.next;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            fast=fast.next;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-15.反转链表</title>
    <url>/2020/11/21/%E5%89%91%E6%8C%87offer-15.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>剑指offer题解。</p>
<a id="more"></a>

<p>题目描述<br>输入一个链表，反转链表后，输出新链表的表头。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)<span class="keyword">return</span> head;</span><br><span class="line">        ListNode post=head.next;</span><br><span class="line">        ListNode pre=<span class="keyword">null</span>;</span><br><span class="line">        ListNode cur=head;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            cur.next=pre;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=post;</span><br><span class="line">            <span class="keyword">if</span>(post!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                post=post.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode222-完全二叉树的节点个数</title>
    <url>/2020/11/24/LeetCode222-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<p>LeetCode题解</p>
<a id="more"></a>
<p>给出一个完全二叉树，求出该树的节点个数。</p>
<p>说明：</p>
<p>完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</p>
<p>来源：力扣（LeetCode）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left=countLevel(root.left);</span><br><span class="line">        <span class="keyword">int</span> right=countLevel(root.right);</span><br><span class="line">        <span class="keyword">if</span>(left==right)&#123;</span><br><span class="line">            <span class="keyword">return</span> countNodes(root.right)+(<span class="number">1</span>&lt;&lt;left);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> countNodes(root.left)+(<span class="number">1</span>&lt;&lt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countLevel</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> level=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            level++;</span><br><span class="line">            root=root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-16.合并两个排序的链表</title>
    <url>/2020/11/23/%E5%89%91%E6%8C%87offer-16.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>剑指offer题解。</p>
<a id="more"></a>

<p>题目描述<br>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        ListNode head =<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode node=head;</span><br><span class="line">        <span class="keyword">while</span>(list1!=<span class="keyword">null</span>&amp;&amp;list2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list1.val&lt;list2.val)&#123;</span><br><span class="line">                node.next=list1;</span><br><span class="line">                list1=list1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                node.next=list2;</span><br><span class="line">                list2=list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            node=node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            node.next=list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            node.next=list2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-18.二叉树的镜像</title>
    <url>/2020/11/23/%E5%89%91%E6%8C%87offer-18.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<p>剑指offer题解。</p>
<a id="more"></a>

<p>题目描述<br>操作给定的二叉树，将其变换为源二叉树的镜像。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        TreeNode temp=root.right;</span><br><span class="line">        root.right=root.left;</span><br><span class="line">        root.left=temp;</span><br><span class="line">        Mirror(root.left);</span><br><span class="line">        Mirror(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode242-有效的字母异位词</title>
    <url>/2020/11/22/LeetCode242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</url>
    <content><![CDATA[<p>LeetCode题解</p>
<a id="more"></a>
<p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p>
<p>示例 1:</p>
<p>输入: s = “anagram”, t = “nagaram”<br>输出: true</p>
<p>来源：力扣（LeetCode）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()!=t.length())<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map&lt;Character,Integer&gt; map =<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            map.put(s.charAt(i),map.getOrDefault(s.charAt(i),<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(t.charAt(i)))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> num=map.get(t.charAt(i));</span><br><span class="line">            num=num-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(num==<span class="number">0</span>)&#123;</span><br><span class="line">                map.remove(t.charAt(i));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(t.charAt(i),num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode452-用最少数量的箭引爆气球</title>
    <url>/2020/11/23/LeetCode452-%20%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83/</url>
    <content><![CDATA[<p>LeetCode题解</p>
<a id="more"></a>
<p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。</p>
<p>一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p>
<p>给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。</p>
<p> <br>示例 1：</p>
<p>输入：points = [[10,16],[2,8],[1,6],[7,12]]<br>输出：2<br>解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球</p>
<p>来源：力扣（LeetCode）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(points.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        Arrays.sort(points,(p1, p2) -&gt; p1[<span class="number">1</span>] &lt; p2[<span class="number">1</span>] ? -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> pos=points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        res++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;points.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(points[i][<span class="number">0</span>]&lt;=pos)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pos=points[i][<span class="number">1</span>];</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-17.树的子结构</title>
    <url>/2020/11/23/%E5%89%91%E6%8C%87offer-17.%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>剑指offer题解。</p>
<a id="more"></a>

<p>题目描述<br>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1==<span class="keyword">null</span>||root2==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isChild(root1,root2)||HasSubtree(root1.left,root2)||HasSubtree(root1.right,root2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isChild</span><span class="params">(TreeNode root1,TreeNode root2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root2==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1.val!=root2.val)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isChild(root1.left,root2.left)&amp;&amp;isChild(root1.right,root2.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-19.顺时针打印矩阵</title>
    <url>/2020/11/23/%E5%89%91%E6%8C%87offer-19.%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<p>剑指offer题解。</p>
<a id="more"></a>

<p>题目描述<br>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</span><br><span class="line">       ArrayList&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">int</span> length=matrix.length;</span><br><span class="line">       <span class="keyword">int</span> width=matrix[<span class="number">0</span>].length;</span><br><span class="line">       <span class="keyword">int</span> left=<span class="number">0</span>,top=<span class="number">0</span>,bottom=length-<span class="number">1</span>,right=width-<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;=right;i++)&#123;</span><br><span class="line">                res.add(matrix[top][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            top++;</span><br><span class="line">            <span class="keyword">if</span>(right&lt;left||bottom&lt;top)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=top;i&lt;=bottom;i++)&#123;</span><br><span class="line">                res.add(matrix[i][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">            <span class="keyword">if</span>(right&lt;left||bottom&lt;top)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=right;i&gt;=left;i--)&#123;</span><br><span class="line">                res.add(matrix[bottom][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            bottom--;</span><br><span class="line">            <span class="keyword">if</span>(right&lt;left||bottom&lt;top)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=bottom;i&gt;=top;i--)&#123;</span><br><span class="line">                res.add(matrix[i][left]);</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span>(right&lt;left||bottom&lt;top)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-21.栈的压入,弹出序列</title>
    <url>/2020/11/23/%E5%89%91%E6%8C%87offer-21.%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5,%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p>剑指offer题解。</p>
<a id="more"></a>

<p>题目描述<br>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>&#123;</span><br><span class="line">          Stack&lt;Integer&gt; s=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">          <span class="keyword">int</span> index =<span class="number">0</span>;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pushA.length;i++)&#123;</span><br><span class="line">              s.push(pushA[i]);</span><br><span class="line">              <span class="keyword">while</span>(!s.isEmpty()&amp;&amp;s.peek()==popA[index])&#123;</span><br><span class="line">                  s.pop();</span><br><span class="line">                  index++;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">return</span> s.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-20.包含MIN函数的栈</title>
    <url>/2020/11/23/%E5%89%91%E6%8C%87offer-20.%E5%8C%85%E5%90%ABMIN%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</url>
    <content><![CDATA[<p>剑指offer题解。</p>
<a id="more"></a>

<p>题目描述<br>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Integer&gt; s=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.isEmpty())&#123;</span><br><span class="line">            s.push(node);</span><br><span class="line">            s.push(node);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(node&lt;s.peek())&#123;</span><br><span class="line">                s.push(node);</span><br><span class="line">                s.push(node);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> num=s.peek();</span><br><span class="line">                s.push(node);</span><br><span class="line">                s.push(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        s.pop();</span><br><span class="line">        s.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num=s.pop();</span><br><span class="line">        <span class="keyword">int</span> res=s.peek();</span><br><span class="line">        s.push(num);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-22.二叉搜索树的后序遍历序列</title>
    <url>/2020/11/24/%E5%89%91%E6%8C%87offer-22.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p>剑指offer题解。</p>
<a id="more"></a>

<p>题目描述<br>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true,否则返回false。假设输入的数组的任意两个数字都互不相同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(sequence,<span class="number">0</span>,sequence.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] sequence,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(end&lt;=start)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> root=sequence[end];</span><br><span class="line">        <span class="keyword">int</span> index=end-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(index&gt;=start&amp;&amp;sequence[index]&gt;root)&#123;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=index;i&gt;=start;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sequence[i]&gt;root)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(sequence,start,index)&amp;&amp;helper(sequence,index+<span class="number">1</span>,end-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-23.二叉树中和为某一值的路径</title>
    <url>/2020/11/24/%E5%89%91%E6%8C%87offer-23.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p>剑指offer题解。</p>
<a id="more"></a>

<p>题目描述<br>输入一颗二叉树的根节点和一个整数，按字典序打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="keyword">int</span> target) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; temp=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(root,temp,res,target,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode node,ArrayList temp,ArrayList res,<span class="keyword">int</span> target,<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        cur+=node.val;</span><br><span class="line">        temp.add(node.val);</span><br><span class="line">        <span class="keyword">if</span>(cur==target&amp;&amp;node.left==<span class="keyword">null</span>&amp;&amp;node.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList(temp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur&lt;target)&#123;</span><br><span class="line">            helper(node.left,temp,res,target,cur);</span><br><span class="line">            helper(node.right,temp,res,target,cur);</span><br><span class="line">        &#125;</span><br><span class="line">        cur-=node.val;</span><br><span class="line">        temp.remove(temp.size()-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode1370-上升下降字符串</title>
    <url>/2020/11/25/LeetCode1370-%E4%B8%8A%E5%8D%87%E4%B8%8B%E9%99%8D%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>LeetCode题解</p>
<a id="more"></a>
<p>给你一个字符串 s ，请你根据下面的算法重新构造字符串：</p>
<p>从 s 中选出 最小 的字符，将它 接在 结果字符串的后面。<br>从 s 剩余字符中选出 最小 的字符，且该字符比上一个添加的字符大，将它 接在 结果字符串后面。<br>重复步骤 2 ，直到你没法从 s 中选择字符。<br>从 s 中选出 最大 的字符，将它 接在 结果字符串的后面。<br>从 s 剩余字符中选出 最大 的字符，且该字符比上一个添加的字符小，将它 接在 结果字符串后面。<br>重复步骤 5 ，直到你没法从 s 中选择字符。<br>重复步骤 1 到 6 ，直到 s 中所有字符都已经被选过。<br>在任何一步中，如果最小或者最大字符不止一个 ，你可以选择其中任意一个，并将其添加到结果字符串。</p>
<p>请你返回将 s 中字符重新排序后的 结果字符串 。</p>
<p> </p>
<p>来源：力扣（LeetCode）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sortString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] num=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            num[s.charAt(i)-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuffer sb =<span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span>(sb.length()&lt;s.length())&#123;</span><br><span class="line">            <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(index&lt;=<span class="number">25</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(num[index]!=<span class="number">0</span>)&#123;</span><br><span class="line">                    sb.append((<span class="keyword">char</span>)(<span class="string">&#x27;a&#x27;</span>+index));</span><br><span class="line">                    num[index]--;</span><br><span class="line">                &#125;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">while</span>(index&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(num[index]!=<span class="number">0</span>)&#123;</span><br><span class="line">                    sb.append((<span class="keyword">char</span>)(<span class="string">&#x27;a&#x27;</span>+index));</span><br><span class="line">                    num[index]--;</span><br><span class="line">                &#125;</span><br><span class="line">                index--;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode34-在排序数组中查找元素的第一个和最后一个位置</title>
    <url>/2020/12/01/LeetCode34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>LeetCode题解</p>
<a id="more"></a>
<p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 target，返回 [-1, -1]。</p>
<p>进阶：</p>
<p>你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗</p>
<p>来源：力扣（LeetCode）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        res[<span class="number">0</span>]=-<span class="number">1</span>;</span><br><span class="line">        res[<span class="number">1</span>]=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">0</span>)<span class="keyword">return</span> res;</span><br><span class="line">        helper(nums,target,start,end,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target,<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span>[] res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(end&lt;start)&#123;</span><br><span class="line">           <span class="keyword">return</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid=start+(end-start)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">            helper1(nums,res,mid,target);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">            helper(nums,target,mid+<span class="number">1</span>,end,res);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            helper(nums,target,start,mid-<span class="number">1</span>,res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper1</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span>[] res,<span class="keyword">int</span> mid,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index=mid;</span><br><span class="line">        <span class="keyword">while</span>(index&gt;=<span class="number">0</span>&amp;&amp;nums[index]==target)&#123;</span><br><span class="line">            res[<span class="number">0</span>]=index;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        index=mid;</span><br><span class="line">        <span class="keyword">while</span>(index&lt;nums.length&amp;&amp;nums[index]==target)&#123;</span><br><span class="line">            res[<span class="number">1</span>]=index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode767-重构字符串</title>
    <url>/2020/11/30/LeetCode767-%E9%87%8D%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>LeetCode题解</p>
<a id="more"></a>
<p>给定一个字符串S，检查是否能重新排布其中的字母，使得两相邻的字符不同。</p>
<p>若可行，输出任意可行的结果。若不可行，返回空字符串。</p>
<p>示例 1:</p>
<p>输入: S = “aab”<br>输出: “aba”<br>示例 2:</p>
<p>输入: S = “aaab”<br>输出: “”</p>
<p>来源：力扣（LeetCode）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reorganizeString</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] aCount=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxIndex=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> threshold=(S.length()+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;S.length();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> index=S.charAt(i)-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            aCount[index]++;</span><br><span class="line">            <span class="keyword">if</span>(aCount[index]&gt;max)&#123;</span><br><span class="line">                max=aCount[index];</span><br><span class="line">                maxIndex=index;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(max&gt;threshold)<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] res=<span class="keyword">new</span> <span class="keyword">char</span>[S.length()];</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(aCount[maxIndex]--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            res[i]=(<span class="keyword">char</span>)(maxIndex+<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            i+=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(index=<span class="number">0</span>;index&lt;aCount.length;index++)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(aCount[index]--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;=S.length())&#123;</span><br><span class="line">                    i=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                res[i]=(<span class="keyword">char</span>)(index+<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">                i+=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcdoe1-两数之和</title>
    <url>/2020/11/09/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p>LeetCode题解</p>
<a id="more"></a>
<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
<p> </p>
<p>示例:</p>
<p>给定 nums = [2, 7, 11, 15], target = 9</p>
<p>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]<br>来源：力扣（LeetCode）</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res=&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target-nums[i]))&#123;</span><br><span class="line">                <span class="keyword">if</span>(i!=map.get(target-nums[i]))&#123;</span><br><span class="line">                    res[<span class="number">0</span>]=map.get(target-nums[i]);</span><br><span class="line">                    res[<span class="number">1</span>]=i;</span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-25.二叉搜索树与双向链表</title>
    <url>/2020/11/30/%E5%89%91%E6%8C%87offer-25.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>剑指offer题解。</p>
<a id="more"></a>

<p>题目描述<br>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    TreeNode pLast=<span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode head=Convert(pRootOfTree.left);</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)&#123;</span><br><span class="line">            head=pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        pRootOfTree.left=pLast;</span><br><span class="line">        <span class="keyword">if</span>(pLast!=<span class="keyword">null</span>)pLast.right=pRootOfTree;</span><br><span class="line">        pLast=pRootOfTree;</span><br><span class="line">        Convert(pRootOfTree.right);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-24.复杂链表的复制</title>
    <url>/2020/11/25/%E5%89%91%E6%8C%87offer-24.%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<p>剑指offer题解。</p>
<a id="more"></a>

<p>题目描述<br>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class RandomListNode &#123;</span></span><br><span class="line"><span class="comment">    int label;</span></span><br><span class="line"><span class="comment">    RandomListNode next = null;</span></span><br><span class="line"><span class="comment">    RandomListNode random = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    RandomListNode(int label) &#123;</span></span><br><span class="line"><span class="comment">        this.label = label;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        RandomListNode node = pHead;</span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            RandomListNode newNode =<span class="keyword">new</span> RandomListNode(node.label);</span><br><span class="line">            newNode.next=node.next;</span><br><span class="line">            node.next=newNode;</span><br><span class="line">            node=newNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        node=pHead;</span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.random!=<span class="keyword">null</span>)node.next.random=node.random.next;</span><br><span class="line">            node=node.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        node=pHead;</span><br><span class="line">        RandomListNode res=pHead.next;</span><br><span class="line">        <span class="keyword">while</span>(node.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            RandomListNode nextNode=node.next;</span><br><span class="line">            node.next=nextNode.next;</span><br><span class="line">            node=nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-26.字符串的排列</title>
    <url>/2020/11/30/%E5%89%91%E6%8C%87offer-26.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<p>剑指offer题解。</p>
<a id="more"></a>

<p>题目描述<br>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则按字典序打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">       ArrayList&lt;String&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="keyword">null</span>||str.length()==<span class="number">0</span>)<span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">char</span>[] strs=str.toCharArray();</span><br><span class="line">        Arrays.sort(strs);</span><br><span class="line">        <span class="keyword">boolean</span>[] used=<span class="keyword">new</span> <span class="keyword">boolean</span>[str.length()];</span><br><span class="line">        StringBuffer sb=<span class="keyword">new</span> StringBuffer();</span><br><span class="line">        helper(strs,used,sb,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">char</span>[] strs,<span class="keyword">boolean</span>[] used,StringBuffer sb,ArrayList res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sb.length()==strs.length)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> String(sb));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;strs.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span>&amp;&amp;strs[i]==strs[i-<span class="number">1</span>]&amp;&amp;!used[i-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(strs[i]);</span><br><span class="line">            used[i]=<span class="keyword">true</span>;</span><br><span class="line">            helper(strs,used,sb,res);</span><br><span class="line">            sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">            used[i]=<span class="keyword">false</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-27.数组中出现次数超过一半的数字</title>
    <url>/2020/12/01/%E5%89%91%E6%8C%87offer-27.%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p>剑指offer题解。</p>
<a id="more"></a>

<p>题目描述<br>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> times=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> result=array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(times==<span class="number">0</span>)&#123;</span><br><span class="line">                result=array[i];</span><br><span class="line">                times=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(array[i]==result)times++;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                times--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        times=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i]==result)times++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(times&gt;array.length/<span class="number">2</span>)<span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-28.最小的K个数</title>
    <url>/2020/12/01/%E5%89%91%E6%8C%87offer-28.%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<p>剑指offer题解。</p>
<a id="more"></a>

<p>题目描述<br>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span>[] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(k&gt;input.length)<span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> low=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high=input.length-<span class="number">1</span>;</span><br><span class="line">        helper(input,k,low,high);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            res.add(input[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] input,<span class="keyword">int</span> k,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low&gt;high)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> section=low-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=low;i&lt;high;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(input[i]&gt;input[high])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                section++;</span><br><span class="line">                swap(input,section,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        section++;</span><br><span class="line">        <span class="keyword">if</span>(section==k+<span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">        swap(input,section,high);</span><br><span class="line">        helper(input,k,low,section-<span class="number">1</span>);</span><br><span class="line">        helper(input,k,section+<span class="number">1</span>,high);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] input,<span class="keyword">int</span> section,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> temp=input[section];</span><br><span class="line">         input[section]=input[i];</span><br><span class="line">         input[i]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-29.连续子数组的最大和</title>
    <url>/2020/12/01/%E5%89%91%E6%8C%87offer-29.%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
    <content><![CDATA[<p>剑指offer题解。</p>
<a id="more"></a>

<p>题目描述<br>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array.length==<span class="number">0</span>||array==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res=Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                sum=array[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sum+=array[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum&gt;res)&#123;</span><br><span class="line">                res=sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode118-杨辉三角</title>
    <url>/2020/12/06/LeetCode118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/</url>
    <content><![CDATA[<p>LeetCode题解</p>
<a id="more"></a>
<p>给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=numRows;i++)&#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; temp=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">0</span>||j==i-<span class="number">1</span>)&#123;</span><br><span class="line">                    temp.add(<span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    List&lt;Integer&gt; lastRow=res.get(i-<span class="number">2</span>);</span><br><span class="line">                    <span class="keyword">int</span> num1=lastRow.get(j-<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">int</span> num2=lastRow.get(j);</span><br><span class="line">                    temp.add(num1+num2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode204-计数质数</title>
    <url>/2020/12/04/LeetCode204-%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0/</url>
    <content><![CDATA[<p>LeetCode题解</p>
<a id="more"></a>
<p>统计所有小于非负整数 n 的质数的数量。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：n = 10<br>输出：4<br>解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</p>
<p>来源：力扣（LeetCode）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[] isPrimes=<span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!isPrimes[i])&#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j*i&lt;n;j++)&#123;</span><br><span class="line">                isPrimes[i*j]=<span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode15-三数之和</title>
    <url>/2020/12/02/LeetCode15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p>LeetCode题解</p>
<a id="more"></a>
<p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<p>来源：力扣（LeetCode）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> left=i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right=nums.length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i-<span class="number">1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                sum=nums[i]+nums[left]+nums[right];</span><br><span class="line">                <span class="keyword">if</span>(sum==<span class="number">0</span>)&#123;</span><br><span class="line">                    ArrayList&lt;Integer&gt; temp=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    temp.add(nums[i]);</span><br><span class="line">                    temp.add(nums[left]);</span><br><span class="line">                    temp.add(nums[right]);</span><br><span class="line">                    res.add(temp);</span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[left]==nums[left+<span class="number">1</span>])&#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[right]==nums[right-<span class="number">1</span>])&#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)left++;</span><br><span class="line">                <span class="keyword">else</span> right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode621-任务调度器</title>
    <url>/2020/12/05/LeetCode621-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8/</url>
    <content><![CDATA[<p>LeetCode题解</p>
<a id="more"></a>
<p>给你一个用字符数组 tasks 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。</p>
<p>然而，两个 相同种类 的任务之间必须有长度为整数 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。</p>
<p>你需要计算完成所有任务所需要的 最短时间 。</p>
<p>来源：力扣（LeetCode）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="keyword">char</span>[] tasks, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] map =<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> task:tasks)&#123;</span><br><span class="line">            map[task-<span class="string">&#x27;A&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(map);</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(map[<span class="number">25</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;=n)&#123;</span><br><span class="line">                <span class="keyword">if</span>(map[<span class="number">25</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;<span class="number">26</span>)&#123;</span><br><span class="line">                    map[<span class="number">25</span>-i]--;</span><br><span class="line">                &#125;</span><br><span class="line">                res++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            Arrays.sort(map);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode659-分割数组为连续子序列</title>
    <url>/2020/12/04/LeetCode659-%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E4%B8%BA%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p>LeetCode题解</p>
<a id="more"></a>
<p>给你一个按升序排序的整数数组 num（可能包含重复数字），请你将它们分割成一个或多个子序列，其中每个子序列都由连续整数组成且长度至少为 3 。</p>
<p>如果可以完成上述分割，则返回 true ；否则，返回 false 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入: [1,2,3,3,4,5]<br>输出: True<br>解释:<br>你可以分割出这样两个连续子序列 :<br>1, 2, 3<br>3, 4, 5</p>
<p>来源：力扣（LeetCode）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPossible</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; nc=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            nc.put(nums[i],nc.getOrDefault(nums[i],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer,Integer&gt; tail=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> count=nc.get(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(count&lt;=<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tail.getOrDefault(nums[i]-<span class="number">1</span>,<span class="number">0</span>)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                nc.put(nums[i],count-<span class="number">1</span>);</span><br><span class="line">                tail.put(nums[i]-<span class="number">1</span>,tail.get(nums[i]-<span class="number">1</span>)-<span class="number">1</span>);</span><br><span class="line">                tail.put(nums[i],tail.getOrDefault(nums[i],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nc.getOrDefault(nums[i]+<span class="number">1</span>,<span class="number">0</span>) &gt; <span class="number">0</span>&amp;&amp;nc.getOrDefault(nums[i]+<span class="number">2</span>,<span class="number">0</span>) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                nc.put(nums[i],count-<span class="number">1</span>);</span><br><span class="line">                nc.put(nums[i]+<span class="number">1</span>,nc.get(nums[i]+<span class="number">1</span>)-<span class="number">1</span>);</span><br><span class="line">                nc.put(nums[i]+<span class="number">2</span>,nc.get(nums[i]+<span class="number">2</span>)-<span class="number">1</span>);</span><br><span class="line">                tail.put(nums[i]+<span class="number">2</span>,tail.getOrDefault(nums[i]+<span class="number">2</span>,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode842-将数组拆分成斐波那契序列</title>
    <url>/2020/12/08/LeetCode842-%E5%B0%86%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86%E6%88%90%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p>LeetCode题解</p>
<a id="more"></a>
<p>给定一个数字字符串 S，比如 S = “123456579”，我们可以将它分成斐波那契式的序列 [123, 456, 579]。</p>
<p>形式上，斐波那契式序列是一个非负整数列表 F，且满足：</p>
<p>0 &lt;= F[i] &lt;= 2^31 - 1，（也就是说，每个整数都符合 32 位有符号整数类型）；<br>F.length &gt;= 3；<br>对于所有的0 &lt;= i &lt; F.length - 2，都有 F[i] + F[i+1] = F[i+2] 成立。<br>另外，请注意，将字符串拆分成小块时，每个块的数字一定不要以零开头，除非这个块是数字 0 本身。</p>
<p>返回从 S 拆分出来的任意一组斐波那契式的序列块，如果不能拆分则返回 []。</p>
<p>来源：力扣（LeetCode）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">splitIntoFibonacci</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] digits=S.toCharArray();</span><br><span class="line">        backtrace(res,digits,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">backtrace</span><span class="params">(List&lt;Integer&gt; res,<span class="keyword">char</span>[] digits,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index==digits.length&amp;&amp;res.size()&gt;=<span class="number">3</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=index;i&lt;digits.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(digits[index]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;i&gt;index)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> num=getNum(digits,index,i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(num&gt;Integer.MAX_VALUE)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> size=res.size();</span><br><span class="line">            <span class="keyword">if</span>(size&gt;<span class="number">2</span>&amp;&amp;(res.get(size-<span class="number">1</span>)+res.get(size-<span class="number">2</span>))&lt;num)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(size&lt;=<span class="number">1</span>||(res.get(size-<span class="number">1</span>)+res.get(size-<span class="number">2</span>))==num)&#123;</span><br><span class="line">                res.add(num);</span><br><span class="line">                <span class="keyword">if</span>(backtrace(res,digits,i+<span class="number">1</span>))<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                res.remove(res.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">char</span>[] digits,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;end)&#123;</span><br><span class="line">            num*=<span class="number">10</span>;</span><br><span class="line">            num+=digits[start]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode861-翻转矩阵后的得分</title>
    <url>/2020/12/07/LeetCode861-%E7%BF%BB%E8%BD%AC%E7%9F%A9%E9%98%B5%E5%90%8E%E7%9A%84%E5%BE%97%E5%88%86/</url>
    <content><![CDATA[<p>LeetCode题解</p>
<a id="more"></a>
<p>有一个二维矩阵 A 其中每个元素的值为 0 或 1 。</p>
<p>移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。</p>
<p>在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。</p>
<p>返回尽可能高的分数。</p>
<p>来源：力扣（LeetCode）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">matrixScore</span><span class="params">(<span class="keyword">int</span>[][] A)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">          <span class="keyword">int</span> m=A.length;</span><br><span class="line">          <span class="keyword">int</span> n=A[<span class="number">0</span>].length;</span><br><span class="line">          count+=m*(<span class="number">1</span>&lt;&lt;(n-<span class="number">1</span>));</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">              <span class="keyword">int</span> nOne=<span class="number">0</span>;</span><br><span class="line">              <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">                  <span class="keyword">if</span>(A[i][<span class="number">0</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">                      nOne+=A[i][j];</span><br><span class="line">                  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                      nOne+=(<span class="number">1</span>-A[i][j]);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">int</span> max=Math.max(nOne,m-nOne);</span><br><span class="line">              count+=max*(<span class="number">1</span>&lt;&lt;(n-j-<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-30.整数中1出现的次数</title>
    <url>/2020/12/07/%E5%89%91%E6%8C%87offer-30.%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<p>剑指offer题解。</p>
<a id="more"></a>

<p>题目描述<br>求出1<del>13的整数中1出现的次数,并算出100</del>1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">1</span>)<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> base =<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> round=n;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(round&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> remain=round%<span class="number">10</span>;</span><br><span class="line">            round/=<span class="number">10</span>;</span><br><span class="line">            count+=round*base;</span><br><span class="line">            <span class="keyword">if</span>(remain==<span class="number">1</span>)&#123;</span><br><span class="line">                count+=(n%base)+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(remain&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                count+=base;</span><br><span class="line">            &#125;</span><br><span class="line">            base*=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-31.把数排成最小的数</title>
    <url>/2020/12/07/%E5%89%91%E6%8C%87offer-31.%E6%8A%8A%E6%95%B0%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</url>
    <content><![CDATA[<p>剑指offer题解。</p>
<a id="more"></a>
<p>题目描述<br>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">PrintMinNumber</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">       String s= <span class="string">&quot;&quot;</span>;</span><br><span class="line">       <span class="keyword">if</span>(numbers==<span class="keyword">null</span>||numbers.length==<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> s;</span><br><span class="line">       &#125;</span><br><span class="line">       ArrayList&lt;Integer&gt; list =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> num : numbers)&#123;</span><br><span class="line">           list.add(num);</span><br><span class="line">       &#125;</span><br><span class="line">       list.sort(<span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1,Integer o2)</span></span>&#123;</span><br><span class="line">               String str1=o1+<span class="string">&quot;&quot;</span>+o2;</span><br><span class="line">               String str2=o2+<span class="string">&quot;&quot;</span>+o1;</span><br><span class="line">               <span class="keyword">return</span> str1.compareTo(str2);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : list)&#123;</span><br><span class="line">        s+=num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
</search>
